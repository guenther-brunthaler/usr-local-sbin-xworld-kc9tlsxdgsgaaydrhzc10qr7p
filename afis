#! /bin/sh
exit_version() {
	wr << =====; exit
$APP version 2025.303.2
Copyright (c) 2025 Guenther Brunthaler. All rights reserved.
=====
}
APP=${0##*/}

exit_help() {
	wr << =====; echo; exit_version
Anti-Forensic Information Splitter (AFIS)

Usage: $APP [ options ] [ <command> [ <parameter> ... ] ]

Usage 1: $APP format <afis_dir_or_backup_dir>

Create the stripes for a AFIS storage.

<afis_dir_or_backup_dir> must be the pathname of the mounted storage, which
 shall be an ext4 formatted volume with a block size of 4096 bytes, "bigalloc"
 ext4 feature enabled and a cluster size of 65536 bytes.

This command must be used for both the primary and backup AFIS storage. It
 will create all the stripes and initialize them with high-quality
 cryptographic pseudorandom numbers.

The 32 bytes at offset 64 KiB of the last stripe will be written differently,
 however. They will be calculated from all previous stripes at the same offset
 and size, being XOR-combined together and also with the text "OK"
 right-padded with ASCII SPACE characters. This will act as a signature that
 all the 32-byte slots following this signature (starting with slot 0) are
 valid.

Usage 2: $APP overwrite <afis_dir> < <whole_store>

The argument is the paths to either the mounted AFIS or the mounted AFIS
 Backup volume.

It will read a binary string with the same size as every stripe.

Then in will randomly select 1/4th of the stripes from the backup volume and
 replace them with new random numbers. After that, one of the remaining
 stripes will be chosen at random and will be replaced by the XOR of the other
 stripes and <whole_store>.

This means that if all stripes will be combined with XOR, <whole_store> will
 result.

<whole_store> must contain the same signature as explained for the "format"
 command. Otherwise, it will not be possible to read or update slots.

Usage 3: $APP reconstruct <afis_dir>

This command will XOR together all stripes found in <afis_dir>, which may
 either be the pathname of the mounted primary or the backup AFIS volume.

It will then write the combined result to standard output, which will be the
 same size as every of the stripes.

Usage 4: $APP write <afis_dir> <slot_number>

This will replace one slot of the AFIS store with new high-quality
 cryptographic random numbers. The remaining slots will not be altered.

The first slot number is 0. Each slot is 32 bytes and all slots are
 contiguous. The slot area starts at offset 64 KiB into the XOR-combined
 stripes. However, slot 0 does not start at the beginning of the slot area.
 Before slot 0 there is a pseudo-slot which contains the constant text "OK"
 padded with ASCII SPACE. This works as a marker that the actual slots are
 valid.

This command is a high-level command which uses the "reconstruct" and
 "overwrite" commands internally in order to do the actual work.

This command shall be used when the pass phrase for a slot is being changed,
 or a slot is taken into use for the first time.

Usage 5: $APP read <afis_dir> <slot_number>

Reads the 32-byte contents from the AFIS slot with index <slot_number> (the
 first slot has index 0) and write it to standard output.

The returned byte-string shall be used as a salt to derive the actual
 decryption key of encrypted data associated with the slot.

Usage 6: $APP encrypt <psw_file> <afis_dir> <slot_number> < <plaintext>

Derives a secondary password from the current contents of slot <slot_number>
 in AFIS base directory <afis_dir>. Then sandwiches the primary password from
 <psw_file> between 2 copies of the secondary password and use the combined
 password to encrypt standard input (which is usually the master password for
 some storage device). The encrypted result is then stored into the slot file
 area of <afis_dir>.

Note that the AFIS slot should be overwritten with new random numbers before
 using a new or updated <psw_file> with this command.

Usage 7: $APP decrypt <psw_file> <afis_dir> <slot_number> > <plaintext>

Derives a secondary password from the current contents of slot <slot_number>
 in AFIS base directory <afis_dir>. Then sandwiches the primary password from
 <psw_file> between 2 copies of the secondary password and use the combined
 password to decrypt the encrypted file associated with <slot_number> from the
 the slot file area of <afis_dir>. The decrypted result is written to standard
 output (which will typically be the master password for some storage device).
=====
}

required_tools='
	gbcrypt2
	haveged
	isaac
	keygen-octets-by-harvesting-entropy
	pwgen-with-entropy-harvesting-as-base62
	xor
'
num_stripes=32
KiB=1024
bytes_per_slot=32
KiB_per_stripe=256
stripe_subdir='stripes'
slot_subdir='slots'
slot_area_KiB_offset=64
set -e

# Provides: trap_errors-3vnzcvh9hfs134g6ln6cy567k
# Version: 2025.299

# Verifies that "set -e" has been set before sourcing this snippet.

case $- in
	*e*) ;;
	*) false || exit
esac

# Provides: scopes-hqxbfzp9026esereelim9tbyk
# Requires: trap_errors-3vnzcvh9hfs134g6ln6cy567k
# Version: 2025.299
#
# Copyright (c) 2022-2025 Guenther Brunthaler. All rights reserved.

# POSIX-compliant portable replacement for the "local"-extension of many
# shells.
#
# It is also much more powerful because it provides a destructor-like
# "finally" mechanism.
#
# This shell script snippet is free software.
# Distribution is permitted under the terms of the GPLv3.
#
# It works like this: Start a logical scope by calling "scope". A good place
# for this is the beginning of a shell function (but it can really be done
# anywhere). Then declare as many variables with "var" as you like and/or use
# "finally" to queue any number of cleanup commands to be executed later.
# "Declaring" variables will queue destructors for restoring the old values
# later. When you are done, call "unwind" at the end of the logical scope
# (such as before leaving a function. This will restore all the original
# variable values and also execute all the "finally" destructors.
#
# Note that "scope"/"unwind" can be nested to arbitrary depth. Functions using
# scopes can thus call other functions using their own scopes.
#
# Arguments for a destructor may be pushed onto the stack using pushvar() and
# push() before queueing the destructor itself with finally(). The destructor
# can then pop the pushed values off the stack (in reverse order) with
# popvar() and use them.
#
# pushvar() is more efficient than push(). Use push() only if the value to be
# pushed onto the stack is not already stored within some variable.
#
# At the end of your script, call shutdown_scopes(). This is not strictly
# necessary but recommended. It verifies that no one forgot to call unwind().
# Never "return" without calling unwind() first from within a scope inside a
# function! shutdown_scopes() also unsets all global variables set by THIS
# script snippet, which means the scope framework functions cannot be called
# any longer.
#
# Not all functions need to use scope/unwind. Only such functions which need
# local variables or destructor functionality should do so.

# Push value from variable with name $1 onto the stack.
pushvar() {
	eval stack_$stack_pointer=\$$1
	stack_pointer=`expr $stack_pointer + 1`
}
stack_pointer=1

# Pop variable with name $1 off the stack.
popvar() {
	stack_pointer=`expr $stack_pointer - 1`
	eval $1=\$stack_$stack_pointer
	unset stack_$stack_pointer
}

# Push value $* onto the stack.
push() {
	v_l9mcnt736v1nhnvy8z2zif4gq=$*
	pushvar v_l9mcnt736v1nhnvy8z2zif4gq
}

# Schedule an expression for evaluation when unwind() is called.
finally() {
	push "$@"
}

# Define a new scope where unwind() will stop.
scope() {
	push
}

# Schedule another list of variables to be restored when unwind() is called.
var() {
	for v_kxelefrxs6up7y7kmkdy194n0
	do
		eval v_l9mcnt736v1nhnvy8z2zif4gq=`:
			`\${$v_kxelefrxs6up7y7kmkdy194n0+set}
		case $v_l9mcnt736v1nhnvy8z2zif4gq in
			'')
				finally unset $v_kxelefrxs6up7y7kmkdy194n0
				;;
			*)
				pushvar $v_kxelefrxs6up7y7kmkdy194n0
				finally popvar $v_kxelefrxs6up7y7kmkdy194n0
		esac
	done
}

# Excute all scheduled "finally" expressions until beginning of scope().
unwind() {
	while :
	do
		popvar v_bwpyjg117sqz7tintf1ridnua
		case $v_bwpyjg117sqz7tintf1ridnua in
			'') break
		esac
		eval "$v_bwpyjg117sqz7tintf1ridnua"
	done
}

# Verify that all resources on the stack have been cleaned up and all
# scheduled destructors have been run. Then unset all global variables set by
# the scope helpers framework. This effectively shuts down the framework.
shutdown_scopes() {
	case $stack_pointer in
		1) ;;
		*) echo "Resource leak!" >& 2; false || exit
	esac
	unset stack_pointer v_bwpyjg117sqz7tintf1ridnua \
		v_kxelefrxs6up7y7kmkdy194n0 v_l9mcnt736v1nhnvy8z2zif4gq
}

# Provides: cleanup-l98e2762zc08fyiqt8787lpk5
# Requires: scopes-hqxbfzp9026esereelim9tbyk
# Requires: trap_errors-3vnzcvh9hfs134g6ln6cy567k
# Version: 2025.299

# Install an error handler which calls unwind() to run all (if any)
# outstanding finally() handlers for cleaning up before actually exiting.

cleanup_l98e2762zc08fyiqt8787lpk5() {
	rc_l98e2762zc08fyiqt8787lpk5=$?
	case $stack_pointer in
		'') ;;
		*)
			while test "$stack_pointer" != 1
			do
				unwind
			done
			
	esac
	test $rc_l98e2762zc08fyiqt8787lpk5 = 0 || echo "\"$0\" failed!" >& 2
	unset rc_l98e2762zc08fyiqt8787lpk5
}
trap cleanup_l98e2762zc08fyiqt8787lpk5 0
trap 'exit $?' INT HUP QUIT TERM PIPE

# Provides: tmpdir-p6fbwwutega7v29jg3ea1s4ws
# Requires: cleanup-l98e2762zc08fyiqt8787lpk5
# Version: 2025.299

cleanup_tmpdir() {
	popvar TD
	rm -r -- "$TD"
}

create_tmpdir() {
	var TD
	TD=`mktemp -d -- "${TMPDIR:-/tmp}/${0##*/}".XXXXXXXXXX`
	pushvar TD
	finally cleanup_tmpdir
}

# Provides: println-871v57a0dzb6d3rxykj87vsnf
# Version: 2025.299

println() {
	printf '%s\n' "$*"
}

# Provides: die-6835duvlwu7m57waedkdiwmgh
# Requires: println-871v57a0dzb6d3rxykj87vsnf
# Version: 2025.299

die() {
	println "$*" >& 2
	false || exit
}

# Provides: main_program-dyiuw0123fp18dmplp53re5ds
# Requires: scopes-hqxbfzp9026esereelim9tbyk
# Requires: tmpdir-p6fbwwutega7v29jg3ea1s4ws
# Requires: die-6835duvlwu7m57waedkdiwmgh

wr() {
	{
		unterminated=false
		while IFS= read -r line
		do
			test "${line%" "}" = "$line"
			test "${line#" "}" != "$line" && unterminated=false
			$unterminated && echo
			printf '%s' "$line"
			unterminated=true
		done
		$unterminated && echo
	} | fold -sw ${COLUMNS:-66}
}

verify_slot_index() {
	expr x"$1" : x'0$' '|' x"$1" : x'[1-9][0-9]*$' > /dev/null
	test $1 -le $last_slot
}

rng_dtor() {
	popvar rng_pid
	exec 8<& -
	kill $rng_pid || :
	wait $rng_pid 2> /dev/null || :
}

# Make cryptographically strong pseudorandom bytestream available via file
# descriptor # 8.
start_rng_fd_8() {
	echo "Harvesting true random seed ..." >& 2
	# Generate a password with 256 bits of entropy gathered from hardware
	# volatility and other sources. This will take a couple of seconds;
	# inform the user about the delay.
	pwgen-with-entropy-harvesting-as-base62 > "$TD"/psw
	# ISAAC needs 1024 bytes as seed. Generate it by encrypting a string
	# of binary zeroes with the password just generated.
	echo "Deriving CSPRNG seed ..." >& 2
	dd $dd_opts if=/dev/zero bs=1024 count=1 > "$TD"/zero 2> /dev/null
	gbcrypt2 -- "$TD"/psw < "$TD"/zero > "$TD"/preseed
	# Data encrypted with "gbcrypt2" starts with a 32 byte nonce followed
	# by the encrypted data, followed by a MAC. Extract only the encrypted
	# data as seed for ISAAC.
	dd $dd_opts if="$TD"/preseed bs=32 skip=1 count=`expr 1024 / 32` \
		of="$TD"/seed 2> /dev/null
	mkfifo -- "$TD"/rng
	var rng_pid
	isaac < "$TD"/seed > "$TD"/rng & rng_pid=$!
	pushvar rng_pid; finally rng_dtor
	exec 8< "$TD"/rng
	rm -- "$TD"/rng "$TD"/seed "$TD"/preseed "$TD"/zero "$TD"/psw
	echo "Done." >& 2
}

# $1: basedir, $2: slot index
stripe_pathname() {
	scope
		var fmt
		fmt=stripe-%0${stripe_index_digits}u.bin
		printf "%s/$fmt" "$1/$stripe_subdir" "$2"
	unwind
}

write_signature() {
	printf '%-32s' OK
}

format_afis() {
	test ! -e "$1/$stripe_subdir"
	test ! -e "$1/$slot_subdir"
	mkdir -m 700 -- "$1/$stripe_subdir" "$1/$slot_subdir"
	scope
		var i spn last_i
		i=0 last_i=`expr $num_stripes - 1`
		start_rng_fd_8
		echo Generating stripes from CSPRNG... >& 2
		while test $i != $num_stripes
		do
			dd $dd_opts <& 8 of="$TD"/stripe \
				bs=$KiB count=$KiB_per_stripe 2>& 5
			if test $i = 0
			then
				cp -- "$TD"/stripe "$TD"/comb
			else
				xor -- "$TD"/comb < "$TD"/stripe \
					> "$TD"/comb.tmp
				mv -- "$TD"/comb.tmp "$TD"/comb
			fi
			if test $i = $last_i
			then
				# Modify last stripe so that it will
				# reconstruct into the slot signature marker.
				write_signature > "$TD"/marker
				dd $dd_opts if="$TD"/stripe \
					bs=$bytes_per_slot \
					skip=$slot_area_offset_slots count=1 \
					of="$TD/current" 2>& 5
				dd $dd_opts if="$TD"/comb bs=$bytes_per_slot \
					skip=$slot_area_offset_slots count=1 \
					2>& 5 \
				| xor -- "$TD"/current \
				| xor -- "$TD"/marker \
				| dd $dd_opts of="$TD"/stripe \
					bs=$bytes_per_slot \
					conv=notrunc \
					seek=$slot_area_offset_slots count=1 \
					2>& 5
			fi
			spn=`stripe_pathname "$1" $i`
			test ! -e "$spn"
			(umask 77; cat -- "$TD"/stripe > "$spn")
			i=`expr $i + 1`
		done 5> /dev/null
		echo $num_stripes stripes have successfully been created.
	unwind
}

verify_afis_dir() {
	test -d "$1/$stripe_subdir"
	test -d "$1/$slot_subdir"
}

# XOR the stripes below base directory $1 together and write them to
# standard output.
reconstruct_afis() {
	scope
		var i spn
		i=0
		while test $i != $num_stripes
		do
			spn=`stripe_pathname "$1" $i`
			test -f "$spn"
			if test $i = 0
			then
				cp -- "$spn" "$TD"/comb
			else
				xor -- "$spn" < "$TD"/comb \
					> "$TD"/comb.tmp
				mv -- "$TD"/comb.tmp "$TD"/comb
			fi
			i=`expr $i + 1`
		done
		cat -- "$TD"/comb
	unwind
}

# Read $1 bytes from standard input and save it to file $2.
read_rest() {
	scope
		var blksz left2read numblks
		blksz=`expr 64 \* 1024` left2read=$1
		{
			if numblks=`expr $left2read / $blksz`
			then
				dd $dd_opts bs=$blksz count=$numblks 2>& 5
				left2read=`
					expr $left2read - $numblks \* $blksz \
					|| :
				`
			fi
			if test "$left2read" != 0
			then
				dd $dd_opts bs=$left2read count=1 2>& 5
			fi
		} > "$2" 5> /dev/null
	unwind
}

# Replace the combined XOR sum of app stripes below AFIS backup base directory
# $1 in such a way that it becomes the contents of $2. During the process of
# replacing the XOR sum, also replace the count of $specials of stripes with
# new random data and randomly select one other stripe for being overwritten
# with the final stripe. Read all random data from file descriptor 8. Exploit
# the fact that file descriptor 5 has been directed to /dev/null.
overwrite_single() {
	scope
		var i k rnd spn last
		i=0
		while test $i != $num_stripes
		do
			rnd=`dd $dd_opts <& 8 bs=9 count=1 2>& 5 | base64`
			echo "$rnd:$i"
			i=`expr $i + 1`
		done | LC_COLLATE=C sort > "$TD"/selected
		i=0
		while IFS=: read rnd k
		do
			spn=`stripe_pathname "$1" $k`
			if test $i -lt $specials
			then
				dd $dd_opts <& 8 of="$TD"/stripe \
					bs=$KiB count=$KiB_per_stripe 2>& 5
				cat -- "$TD"/stripe > "$spn"
			elif test $i = $specials
			then
				last=$spn
				cp -- "$2" "$TD"/stripe
			else
				cp -- "$spn" "$TD"/stripe
			fi
			if test $i = 0
			then
				cp -- "$TD"/stripe "$TD"/comb
			else
				xor -- "$TD"/comb < "$TD"/stripe \
					> "$TD"/comb.tmp
				mv -- "$TD"/comb.tmp "$TD"/comb
			fi
			i=`expr $i + 1`
		done < "$TD"/selected
		cat -- "$TD"/comb > "$last"
	unwind
}

calc_specials() {
	var specials
	# floor($num_stripes / 100 * 25 + 0.5)
	specials=`expr \( $num_stripes \* 50 + 100 \) / 200`
}

# Replace the combined XOR sum of app stripes below AFIS base directory $1
# with the contents of file $2. During the process of replacing the XOR sum,
# also replace 25 % of the stripes with new random data and randomly select
# one other stripe for being overwritten with the final stripe.
overwrite_afis() {
	scope
		calc_specials
		start_rng_fd_8
		overwrite_single "$1" "$2" 5> /dev/null
	unwind
}

# Check the signature in reconstructed slot area in file $1.
verify_slots() {
	{
		dd $dd_opts if="$1" bs=$bytes_per_slot \
			skip=$slot_area_offset_slots \
			count=1 of="$TD"/has 2>& 5
		write_signature > "$TD"/shall 2>& 5
		if cmp -s -- "$TD"/has "$TD"/shall
		then
			rm -- "$TD"/has "$TD"/shall
		else
			die "Invalid slot area signature!"
		fi
	} 5> /dev/null
}

# Reconstruct the slots in AFIS base directory $1 into "$TD/slots" and verify
# that the signature is correct.
verify_afis() {
	reconstruct_afis "$1" > "$TD"/slots
	verify_slots "$TD"/slots
}

# Write the contents of slot $2 below AFIS base directory $1 to standard
# output.
read_afis_slot() {
	verify_afis "$1"
	dd $dd_opts if="$TD/slots" bs=$bytes_per_slot \
		skip=`expr $slot_area_offset_slots + 1 + $2` \
		count=1 2> /dev/null
}

# Replace the contents of slot $2 below AFIS base directory $1 to standard
# with new random numbers derived from CSPRNG seeded with true random numbers.
write_afis_slot() {
	verify_afis "$1"
	scope
		verify_afis "$1"
		start_rng_fd_8
		calc_specials
		{
			dd $dd_opts <& 8 conv=notrunc of="$TD/slots" \
				bs=$bytes_per_slot \
				seek=`expr $slot_area_offset_slots + 1 + $2` \
				count=1 2>& 5
			overwrite_single "$1" "$TD"/slots
		} 5> /dev/null
	unwind
}

# Derive a combined password from user-provided password in file $1 and from a
# secondary password derived from slot $3 of AFIS base directory $2. Save the
# combined password as file "$TD/psw".
derive_psw() {
	read_afis_slot "$2" "$3" | base64 | tr -d = > "$TD"/psw2
	{
		cat -- "$TD"/psw2 "$1" "$TD"/psw2 | tr -d '\n'
		echo
	} > "$TD"/psw
	rm -- "$TD"/psw2
}

# Use user-provided password in file $1 in order to encrypt a master password
# read from stdin and store the encrypted file in AFIS directory $2 associated
# with slot $3.
encrypt_afis_slot() {
	derive_psw "$@"
	gbcrypt2 "$TD"/psw > "$2/$slot_subdir/$3.gc2"
}

# Use user-provided password in file $1 in order to decrypt the encrypted file
# in AFIS directory $2 associated with slot $3 and write the decrypted master
# password to stdout.
decrypt_afis_slot() {
	derive_psw "$@"
	gbcrypt2 "$TD"/psw "$2/$slot_subdir/$3.gc2"
}

slots_per_KiB=`expr $KiB / $bytes_per_slot`
stripe_index_digits=`expr $num_stripes - 1`
stripe_index_digits=${#stripe_index_digits}
last_slot=`
	expr \( $KiB_per_stripe - $slot_area_KiB_offset \) \
		\* $slots_per_KiB - 1
`
slot_area_offset_slots=`expr $slot_area_KiB_offset \* $slots_per_KiB`
dd_opts=iflag=fullblock
echo | dd $dd_opts > /dev/null 2>& 1 || dd_opts=
scope
	scope
		var tool is_all_ok
		is_all_ok=true
		for tool in $required_tools
		do
			command -v "$tool" >& 5 2>& 5 && continue
			echo "Required utility '$tool'" \
				"could not be found!" >& 2
			is_all_ok=false
		done 5> /dev/null
		$is_all_ok
	unwind
	scope
		var opt
		while getopts hV opt
		do
			case $opt in
				h) unwind; exit_help;;
				V) unwind; exit_version;;
				*) false || exit
			esac
		done
		shift `expr $OPTIND - 1 || :`
	unwind
	create_tmpdir
	case `stat -f -c '%T' -- "$TD"` in
		ramfs | tmpfs) ;;
		*) die "Directory '${TMPDIR:-/tmp}' must be a tmpfs or ramfs!"
	esac
	case $1 in
		format)
			test $# = 2; test -d "$2"
			format_afis "$2"
			;;
		reconstruct)
			test $# = 2
			verify_afis_dir "$2"
			reconstruct_afis "$2"
			;;
		overwrite)
			test $# = 2
			verify_afis_dir "$2"
			read_rest `expr $KiB \* $KiB_per_stripe` \
				"$TD"/whole_store
			verify_afis "$2"
			overwrite_afis "$2" "$TD"/whole_store
			;;
		write)
			test $# = 3
			verify_afis_dir "$2"
			verify_slot_index "$3"
			write_afis_slot "$2" "$3"
			;;
		read)
			test $# = 3
			verify_afis_dir "$2"
			verify_slot_index "$3"
			read_afis_slot "$2" "$3"
			;;
		encrypt)
			test $# = 4
			test -f "$2"
			verify_afis_dir "$3"
			verify_slot_index "$4"
			encrypt_afis_slot "$2" "$3" "$4"
			;;
		decrypt)
			test $# = 4
			test -f "$2"
			verify_afis_dir "$3"
			verify_slot_index "$4"
			decrypt_afis_slot "$2" "$3" "$4"
			;;
		'') die "A command verb must be specified!";;
		*) die "Unsupported command '$1'!"
	esac
unwind
shutdown_scopes
