#! /bin/sh
show_version() {
	wr <<- .
	$APP version 13.18

	(c) 2013 by Guenther Brunthaler.\n
	Distribution is permitted under the terms of the GPLv3.
.
}
APP=${0##*/}


# Where to find settings.
SETTINGS_FILE=/etc/default/grub

# How to refer to grub in messages.
GRUBNAME=GRUB2

# How to refer to /boot/grub/grub.cfg in messages.
GRUBCFG_NAME=grub.cfg

# UUID of the partition where to install GRUB to. Can be prefixed by
# "parent_of:", in which case the disk containing that partition will be used
# instead as the installation device.
GRUB_INSTALL_DEVICE_UUID= # Actual value will be sourced from "$SETTINGS_FILE".


show_help() {
	wr <<- .
	$APP - reinstall $GRUBNAME boot loader
	
	Usage: $APP [ options ]
	
	$APP reinstalls the $GRUBNAME executables and refreshes the block
	lists if necessary.
	
	It is not necessary to call $APP if just the $GRUBNAME $GRUBCFG_NAME
	file has changed.
	
	But $APP should always be called after the $GRUBNAME installation
	package has been updated, or ig the boot device/partition has changed.
	
	$APP reads the setting GRUB_INSTALL_DEVICE_UUID from the file
	"$SETTINGS_FILE" in order to determine where to install $GRUBNAME to.
	
	The value of this setting can be a UUID in lower case, just as it will
	be displayed by executing
	
	\$ blkid -o value -s UUID /dev/<partition>
	
	Optionally, this value can be prefixed by the string "parent_of:".
	
	In this case, the disk containing the specified partition will be used
	as the installation device, rather than the partition with the
	specified UUID itself.
	
	Options:

	-n:\n
	    Dry run. Show the installation command which would be executed,
	    but don't actually do anything.\n
	-r:\n
	    Re-check the partition layout and drive numbering and discard any
	    cached information from previous runs about this.\n
	-h: Show this help.\n
	-V: Show only the version information.\n
.
	println
	show_version
}


run() {
	"$@" && return
	echo "ERROR: Command >>>$*<<< failed with return code ${?}!" >& 2
	false; exit
}


println() {
	run printf '%s\n' "$*"
}


wr() {
	local REPLY
	while IFS= read -r REPLY
	do
		{
			while test -n "$REPLY" || IFS= read -r REPLY
			do
				ORIG=$REPLY; REPLY=${REPLY%\\n}
				println "$REPLY"
				test x"$ORIG" != x"$REPLY"  && break
				REPLY=
			done
		} | run fmt -w "$LINEWIDTH" || exit
	done
}
LINEWIDTH=; tty -s && LINEWIDTH=`tput cols` || LINEWIDTH=; : ${LINEWIDTH:=70}


print_device() {
	(
		. "$SETTINGS_FILE"
		println "$GRUB_INSTALL_DEVICE_UUID"
	)
}


DRY_RUN=
RECHECK=
while getopts nrhV OPT
do
	case $OPT in
		n) DRY_RUN=Y;;
		r) RECHECK=Y;;
		h) show_help; exit;;
		V) show_version; exit;;
		*) false; exit
	esac
done
shift `expr $OPTIND - 1`
run test $# = 0
run test -f "$SETTINGS_FILE"
GRUB_INSTALL_DEVICE_UUID=`print_device`
run test -n "$GRUB_INSTALL_DEVICE_UUID"
use_parent=${GRUB_INSTALL_DEVICE_UUID#parent_of:}
set -- "Installation device is"
if test x"$use_parent" != x"$GRUB_INSTALL_DEVICE_UUID"
then
	GRUB_INSTALL_DEVICE_UUID=$use_parent
	set -- "$@" "disk containing"
else
	use_parent=
fi
echo "$* partition with UUID $GRUB_INSTALL_DEVICE_UUID."
dev=`run blkid -U "$GRUB_INSTALL_DEVICE_UUID"` || exit
if test -n "$use_parent"
then
	use_parent=${dev%%[0-9]}
	test x"$use_parent" != x"$dev"
	dev=$use_parent
fi
run test -b "$dev"
GRUB_BIN=`which grub2-install 2> /dev/null` \
|| GRUB_BIN=`run which grub-install 2> /dev/null` || exit
echo "Installing $GRUBNAME boot sector into $dev..."
if test -n "$DRY_RUN"
then
	set -- echo "SIMULATION:"
else
	set --
fi
set -- run "$@" "$GRUB_BIN" --no-floppy
test -z "$use_parent" && set -- "$@" --force
test -n "$RECHECK" && set -- "$@" --recheck
"$@" "$dev"
