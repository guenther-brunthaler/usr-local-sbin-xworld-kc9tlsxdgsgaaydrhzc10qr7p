#! /usr/bin/perl -w
#
# Generate a script which when run recompiles each and every package
# in the Gentoo system.
# This will typically be required on a major GCC upgrade.
#
my $VERSION= '10.251';
my $written= '(c) 2006-2010 Guenther Brunthaler';


use strict;
use File::Temp ':POSIX';
use Getopt::Long;


# Change this to any name you like.
my $script= "recompile-remaining-packages";


my $script_header= &expand_specials(<< '.');
#! /bin/bash
#
# Run this script repeatedly (if interrupted)
# until no more packages will be compiled.
#
# Version @VERSION@
# @written@


SCRIPT_VERSION=@VERSION@


die() {
	echo "ERROR: $*" >& 2; false; exit
}

RM() {
	rm "$1" || die "Could not remove file '$1': $!!"
}

MV() {
	mv "$1" "$2" || die "Could not rename file '$1' into '$2': $!!"
}

CHMOD() {
	chmod $* || die "Could not set permissions 'chmod $*': $!!"
}

save_progress() {
	{
		echo "$VERSION"; echo "$OURGCC"
		echo "$PROGRESS $OK $FAILED"
	} > "$STATE_FILE"
}

item() {
	test "$PROGRESS" -ge "$1" && return
	echo "Emerging package # $1 ('$2')..."
	local RC; emerge !<EMERGE_OPTS>! "$2"; RC=$?
	if [ $RC = 0 ]; then
		echo "Package # $1 rebuild complete."
		(( ++OK ))
	elif [ $RC -gt 100 ]; then
		echo "Emerge failed return code $?. Aborting on user request."
		exit 1
	else
		echo "Emerge failed return code $? (will be retried later)."
		(( ++FAILED ))
		echo "$2" >> "$FAILURES_FILE"
	fi
	echo; PROGRESS="$1"; save_progress
}


BASENAME=${0##*/}
STATE_FILE="$HOME/.$BASENAME.state"
FAILURES_FILE="$HOME/.$BASENAME.failures"
LOG_FILE="!<LOGDIR>!/${BASENAME}_$(date '+%Y-%m-%d_%T').log"
REPEAT="--4ydzd3yuhmsynbjr644bbfzx5"
if [ "$1" != "$REPEAT" ]; then
	exec > >(
		echo "Note: Logging to file '$LOG_FILE'."
		tee "$LOG_FILE"
		echo
		echo "Note: A log has been written to '$LOG_FILE'."
	)
fi
OURGCC="`gcc-config --get-current-profile`" || die "gcc-config failed!"
VERSION=; LASTGCC=; PROGRESS=; OK=; FAILED=
{
	read VERSION; read LASTGCC; read PROGRESS OK FAILED
}  2> /dev/null < "$STATE_FILE"
if [ "$VERSION" != "$SCRIPT_VERSION" -o "$OURGCC" != "$LASTGCC" ]; then
	VERSION="$SCRIPT_VERSION"; true > "$FAILURES_FILE"
	PROGRESS=0; OK=0; FAILED=0; save_progress
fi

# Now the list of packages to be recompiled follows.
.

my $script_tail= << '.';
# End of package list.

echo
if [ $FAILED = 0 ]; then
	echo "Success! All packages have been re-compiled."
	echo "Your system is now up-to-date with respect to $OURGCC!"
elif [ $OK = 0 ]; then
	echo "Giving up: Could not compile any more packages in the current"
	echo "recompilation phase."
	echo "Look into the 'item'-lines of script '$0'"
	echo "to see which packages could not be recompiled."
else
	echo "Partial success: The current recompilation phase has"
	echo "finished."
	echo
	echo "However, $FAILED packages were not compiled successfully"
	echo "in this phase."
	echo
	echo "Therefore, another phase will be started now, where an attempt"
	echo "will be made to recompile the remaining packages."
	echo
	echo "Note that this will *not* lead into an infinite loop:"
	echo "In the last phase $OK packages have been compiled"
	echo "successfully, and thus the total number of remaining"
	echo "packages has been diminished already."
	echo
	ME="$0"
	if [ ! -e "$ME" ]; then
		ME="$(which "$ME")"
		test -e "$ME" || die "Cannot locate '$0'"
	fi
	NEW="${ME}_$$.tmp"
	(
		IFS=$'\n'
		while read -r LINE; do
			test "$LINE" != "${LINE#item }" && break
			echo "$LINE"
		done
		{
			while read -r LINE; do
				echo "item $(( ++PROGRESS )) $LINE"
			done
		} < "$FAILURES_FILE"
		while read -r LINE; do
			if [ "$LINE" = "${LINE#item }" ]; then
				echo "$LINE"
				break
			fi
		done
		while read -r LINE; do echo "$LINE"; done
	) < "$ME" > "$NEW"
	CHMOD --reference="$ME" "$NEW"; RM "$ME"; MV "$NEW" "$ME"
	VERSION="NONE"; save_progress
	exec "$ME" "$REPEAT"
fi
RM "$FAILURES_FILE"; RM "$STATE_FILE"
.

my $info1= &expand_specials(<< '.');
Recompile Entire System Helper

Version @VERSION@
@written@

This script will generate another script to be run by you. That other script
will then recompile each and every package in the whole system in the correct
order.

This will typically be required on a major GCC upgrade.

When the generated script will be run, it will log all of its screen output
to a log file.

Furthermore, the generated script will automatically skip failing packages and
automatically attempt to recompile them again after all the other packages
have been recompiled.

IMPORTANT: Do not execute this script without also following the steps of the
accompanying usage guide.

The guide can be found at
http://forums.gentoo.org/viewtopic-t-494331-highlight-.html

Press [Ctrl]+[C] now in order to abort processing if you are not following the
guide step by step. Come back and re-run this script after you have managed to
get the guide.

Press [Enter] now to continue if you dare.

.


sub expand_specials {
   my $t= $_[0];
   $t =~ s/\@VERSION\@/$VERSION/g;
   $t =~ s/\@written\@/$written/g;
   return $t;
}


# Remove the largest common whitespace prefix from all lines
# of the first argument.
# (Empty lines or lines containing only whitespace are skipped
# by this operation and will be replaced by
# completely empty lines.)
# The first argument must either be a reference to a multiline
# string containing newline characters or a reference to an
# array of single line strings (without newline characters).
# Then optionally indent all resulting lines with the prefix
# specified as the argument to the -first option.
# For all indented lines do the same, but use the argument
# to option -indent as the value of the -first option then.
# If option -wrap <number> is specified, contiguous non-empty
# lines of the same indentation depth are considered paragraphs,
# and will be word-wrapped on output, resulting in a maximum
# total line length of <number> characters.
# The word-wrapping will occur on whitespaces, which can be
# protected by a backslash. Backslash-protected newlines
# will be interpreted as forced line ends.
sub normalize_indentation {
   my($tref, %opt)= @_;
   my(@t, $t, $p, $pl);
   $opt{-first}||= '';
   $opt{-indent}||= ' ';
   # Coerce into array of lines.
   $t= ref($tref) eq 'ARRAY' ? $tref : [split /\n/, $$tref];
   # Find shortest common WS prefix of all lines.
   foreach (@$t) {
      s/\s+$//; # Eliminate trailing WS (and WS-only lines).
      next if $_ eq ''; # Ignore empty lines in prefix check.
      if (defined $pl) {
         for (;;) {
            substr($p, $pl= length)= '' if length() < $pl;
            last if substr($_, 0, $pl) eq $p; # $p is a prefix of $_.
            substr($p, --$pl)= ''; # Reduce common prefix.
         }
      } else {
         ($p)= /^(\s*)/; # WS prefix of first line.
         $pl= length $p; # Prefix length.
      }
   }
   # Remove common WS prefix from all non-empty lines.
   substr($_, 0, $pl)= '' foreach grep $_ ne '', @$t;
   if (exists $opt{-wrap}) {
      # Word-wrap lines.
      my $width= $opt{-wrap} - length $opt{-first};
      my $i;
      my $wrap= sub {
         my($tref, $aref, $iref, $w)= @_;
         my $buf;
         my $insert= sub {
            my($tref, $aref, $iref)= @_;
            splice @$aref, $$iref++, 0, $$tref if defined $$tref;
            undef $$tref;
         };
         return unless $$tref;
         foreach (split /(?:(?<!\\)\s)+/, $$tref) {
            s/\\\s/ /gs;
            if (length($buf || '') + length > $w) {
               &$insert(\$buf, $aref, $iref);
            }
            if (defined $buf) {$buf.= " $_"} else {$buf= $_}
         }
         &$insert(\$buf, $aref, $iref);
         undef $$tref;
      };
      $width= 1 if $width < 1;
      undef $p; # Paragraph accumulator.
      # Process all lines.
      for ($i= 0; $i < @$t; ) {
         if ($t->[$i] =~ /^(?:\s|$)/) {
            # Start a new paragraph after this.
            &$wrap(\$p, $t, \$i, $width);
            ++$i;
         } else {
            # Move current line to end of paragraph.
            if (defined $p) {$p.= ' '} else {$p= ''}
            $p.= $t->[$i];
            splice @$t, $i, 1;
         }
      }
      &$wrap(\$p, $t, \$i, $width);
   }
   # Indentation level complete. Recurse for sublevels.
   for (my $i= 0; $i < @$t; ) {
      if ($t->[$i] =~ /^\s/) {
         push @t, splice @$t, $i, 1;
         next;
      }
      if (@t) {
         &normalize_indentation(\@t, %opt, -first => $opt{-indent});
         splice @$t, $i, 0, @t;
         $i+= @t;
         @t= ();
      }
      ++$i;
   }
   if (@t) {
      &normalize_indentation(\@t, %opt, -first => $opt{-indent});
      push @$t, @t;
   }
   # Prepend requested initial indentation before all lines.
   substr($_, 0, 0)= $opt{-first} foreach grep $_ ne '', @$t;
   # Return result in the same format (string, array) as has been passed in.
   $$tref= join '', map "$_\n", @$t if ref($tref) ne 'ARRAY';
}


sub wrap0(@) {
   my $text= join ' ', @_;
   normalize_indentation \$text, -indent => '    ', -wrap => 79;
   return \$text;
}


sub pwrap(@) {
   print ${wrap0 @_};
}


$ENV{LC_ALL}= "C";
my $home= $ENV{HOME};
unless ($home && -d $home) {
   die 'Please set $HOME to your home directory';
}
$home =~ s!/*$!/!;
substr($script, 0, 0)= $home;
Getopt::Long::Configure("bundling");
my $logdir= substr $home, 0, length($home) - 1;
my $pkgs;
my $emerge_opts= '--oneshot --nodeps';
my $names_only;
my $prog= $0;
$prog =~ s!.*[/\\]!!;
GetOptions(
     'p|package-list=s' => \$pkgs
   , 'd|log-dir=s' => \$logdir
   , 'e|emerge-options=s' => \$emerge_opts
   , 'o|output-script-name=s' => \$script
   , 'n|names-only' => \$names_only
   , 'h|help' => sub {
      pwrap expand_specials << ".";
         $prog - generate a bulk emerge script
         
         $prog creates a package list from the combined output of
         
            emerge --pretend --emptytree system
            
         and

            emerge --pretend --emptytree world
            
         which will be sanitized and stripped of duplicates.

         Then this package list will be used in order to generate a script
         file which will emerge all those packages in an unattended batch
         operation. (All output will be logged for later review.)

         Furthermore, the script will work in a way which allows interruptions
         and is able to continue at the package where it was interrupted when
         called the next time.

         The generated script is also tolerant to build failures, and will
         retry rebuilding failing ebuilds again at the end. This can greatly
         help in resolving (ostensibly) circular dependencies.

         This will effectively rebuild your entire system using the currently
         installed GCC.

         Options:

         --log-dir <directory>\\
         -d <directory>

            Use this directory for creating the build log file which contains
            the full output from the emerge operations. Beware: This file can
            get pretty large! Defaults to \$HOME.

         --emerge-options "<opt1> <opt2> ..."\\
         -e "<opt1> <opt2> ..."

            The command-line options to be used for emerge. Defaults to
            "--oneshot\\ --nodeps". If more than one argument shall be passed
            through that way, be sure to enclose the whole argument within
            quotes, because it must be specified as a single option argument.

         --package-list <file>\\
         -p <file>

            This option must not be used for normal operation of the script.

            It allows to mis-use this script in order to not rebuild your
            entire system, but rather to generate a script for batch-emerging
            the packages specified in <file>.

            Each line in <file> must contain a single valid package definition
            in the format <category>/<package> or
            <category>/<package>-<version>.

            The packages will then be emerged in exactly that order, using the
            emerge options as specified with --emerge-options (or using the
            default value for --emerge-options otherwise).
            
         --output-script-name <filename>\\
         -o <filename>
         
            This allows to override the default name of the script which will
            be generated. It will always be generated in the user's home
            directory.
         
         --names-only\\
         -n
         
            By default, the exact package versions will be included in the
            generated script. With this version, the version numbers will be
            stripped. This leads to installation of the newest version of that
            package. Beware that this option might be dangerous, because
            sometimes package dependencies require older versions of a
            dependency in order to work. This option assumes the current list
            of packages contains version numbers. It must therefore not be
            used if the --package-list is also used and the entries in the
            user-provided package list do not all have version numbers.

         --help\\
         -h

            Display this text. Hint: Try

               $prog --help | less

            if the above text scrolled off your screen before you could read
            it.

         $prog Version \@VERSION\@\\
         \@written\@.
.
      exit;
   }
) or die;
die "Bad log directory '$logdir'" unless -d $logdir;
if (-e $script) {
   die "Please remove the existing '$script'.\nIt is in the way";
}
my($n, $tmp);
unless ($pkgs) {
   pwrap "$prog -", $info1;
   <STDIN>;
   $tmp= tmpnam or die "No temporary file names left";
   print "Collecting list of packages and evaluating installation order...\n";
   my @head= qw(
      sys-kernel/linux-headers
      sys-devel/gcc
      sys-libs/glibc
      sys-devel/binutils
   );
   my $r= join '|', map quotemeta, @head;   
   $r= qr/ ^ (?: $r ) - \d /x;
   open OUT, (
      '| sort -k1,1 | sort -suk3,3 | sort -nk2,2 | sort -sk1,1 '
      . '| cut -d" " -f3 >> "' . $tmp . '"'
   ) or die "Cannot open output pipe: $!";
   $n= 0;
   foreach my $f (qw/system world/) {
      open IN, "emerge -pe $f |" or die "Cannot open input pipe for '$f': $!";
      while (defined($_= <IN>)) {
         if (/]\s+(.*?)\s/) {
            (my $t, $_)= ($f, $1);
            if (/$r/o) {
               for (my $i= @head; $i--; ) {
                  my $L= length $head[$i];
                  if (length >= $L && substr($_, 0, $L) eq $head[$i]) {
                     print OUT "begin $i";
                     goto field3;
                  }
               }
            }
            print OUT "$t ", ++$n;
            field3:
            if ($names_only) {
               if (
                  /
                     \G .*?
                     ( # $1.
                        (?:
                           # Optional prefix and category.
                           (?:
                              # Comparison prefixes.
                              ( # $2.
                                 < | <= | = | >= | >
                              )
                           )?
                           ( # $3.
                              # Category.
                              [a-zA-z0-9+_] [-a-zA-z0-9+_]*
                           )
                           \/
                        )?
                        ( # $4.
                           # Package base name.
                           (?: [a-zA-z0-9+_] [-a-zA-z0-9+_]*? )?
                           [a-zA-z0-9+_]
                        )
                        # Optional "-version-revision"-part.
                        (?:
                           -
                           ( # $5.
                              # Package version.
                              (?: cvs \. )?
                              # Main part of version number.
                              \d+ (?: \. \d+ )*
                              [a-z]?
                              (?: _ (?: pre | p | beta | alpha | rc ) \d* )*
                           )
                           # Option -r revision suffix.
                           (?:
                              # Revision $rev.
                              -
                              ( # $6.
                                 r \d+
                              )
                           )?
                        )?
                        # Optional ":something" package-slot name.
                        (?:
                           :
                           ( # $7.
                              # Package version.
                              (?: cvs \. )?
                              # Main part of version number.
                              \d+ (?: \. \d+ )*
                              [a-z]?
                              (?: _ (?: pre | p | beta | alpha | rc ) \d* )*
                              # Optional -r revision suffix.
                              (?:
                                 # Revision $rev.
                                 - r \d+
                              )?
                           )
                        )?
                        # Terminator.
                        (?: (?= [^-+_[:alnum:]] ) | $ )
                     )
                  /xg
               ) {
                  $_= "$3/$4";
                  $_.= ":$7" if $7;
               } else {
                  die "No correct package+version syntax in entry '$_'!";
               }
            } else {
               substr($_, 0, 0)= '=';
            }
            print OUT " $_\n";
         }
      }
      close IN or die $!;
   }
   close OUT or die $!;
   open IN, '<', $tmp or die "Cannot open file '$tmp': $!";
} else {
   open IN, '<', $pkgs or die "Cannot open file '$pkgs': $!";
}
open OUT, '>', "$script" || die "Could not create '$script': $!";
$script_header =~ s/!<LOGDIR>!/$logdir/ or die;
$script_header =~ s/!<EMERGE_OPTS>!/$emerge_opts/ or die;
print OUT $script_header;
$n= 1;
while (defined($_= <IN>)) {
   if ($pkgs) {
      unless (m{^[^/\s]+/[^/\s]+$}) {
         chomp;
         die "Bad package name '$_' in file '$pkgs'";
      }
   }
   print OUT "item $n $_"; ++$n;
}
print OUT $script_tail;
close OUT or die "Could not finish writing '$script': $!";
close IN or die $!;
unless ($pkgs) {
   unlink($tmp) == 1 or warn "Could not remove temorary file '$tmp': $!";
}
unless (chmod(0755, $script) == 1) {
   die "Could not set permissions for '$script': $!";
}
pwrap << ".";
Done.

Script "$script" has been generated.

Run this script in order to recompile each and every package in the
system!

By the way, the generated script will do this in a recoverable way:
It can be aborted at any time by you, and will continue where it left off
when you re-run it. (The package where the script was interrupted will
have to be compiled again from its beginning, though.)
.
