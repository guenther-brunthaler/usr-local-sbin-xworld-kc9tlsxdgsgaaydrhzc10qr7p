#! /bin/sh
show_version() {
	wr -s <<-.
	$APP version 13.174

	(c) 2007 - 2013 by Guenther Brunthaler.
	Distribution is permitted under the terms of the GPLv3.
.
}
APP=${0##*/}


show_help() {
	wr <<-.
	$APP - mount a VFAT volume on a flash storage medium using appropriate
	options
	
	Uses the correct options for setting umask, dmask, character set
	translation, owner, group, etc.

	Usage:
	  vfatmount [ options ] <device> <mount_point_directory>
	
	<device>:
	  The device or image file containg the volume data of the FAT16 or
	  FAT32 file system. If it is a file rather than a block special
	  device, 'loop' will automatically be added to the default options.

	Command line options accepted by $APP:

	--dry-run, --simulate, -n:
	  Just print what would be done, but don't actually do anything.

	--read-only, -r:
	  Add 'ro' to the default options.

	--create-mountpoint, -c, -m:
	  If the mount point directory does not yet exist, it will be created
	  using the provided path name.

	--options, -o <more_options>:
	  Will be added to the list auf default options. Can be used to
	  specify additional mount options such "remount" which will not be
	  used by default.

	--:
	  Stop parsing for command line options. Any arguments following this
	  option will be interpreted as normal arguments, even if they start
	  with "-" or "--".

	--help, -h, --usage:
	  Display this help.

	--version, -V:
	  Show version information.

	"Switch clustering" for short-options (single-dash options) is
	supported. For instance, when specifying two separate options "-h" and
	"-V", the combined option argument "-hV" means exactly the same thing.

.
	show_version
}



MOPT_VFAT_BASE="utf8=true,uid=operator,gid=plugdev"
MOPT_VFAT_RW="noatime,umask=117,dmask=007"
MOPT_VFAT_RO="ro,umask=337,dmask=227"
PREFER_IOSCHEDULER=anticipatory
IOSCHEDULER_MODULE=as_iosched
IOSCHED_SYSPATH="/sys/block/*/queue/scheduler"


die() {
	echo "ERROR: $*" >& 2
	false; exit
}


run() {
	"$@" && return
	die "Could not execute >>>$*<<< - failed with return code ${?}!"
}


system() {
	REPLY=`run "$@"` || exit
}


wr() {
	test -z "$*" && set -- -c
	fmt -w "$LINEWIDTH" "$@"
}
LINEWIDTH=; tty -s && LINEWIDTH=`tput cols` || LINEWIDTH=; : ${LINEWIDTH:=70}


write_to() {
	run printf '%s\n' "$1" > "$2"
}


silent() {
	"$@" > /dev/null 2>& 1
}


inform() {
	if
		test -n "$VERBOSE"
	then
		run printf '%s\n' "$*" >& 2
	fi
}


when_real() {
	if
		test -z "$CPFX"
	then
		"$@"
	else
		echo "SIMULATION: $*" >& 2
	fi
}


# Start of command line processing.
# Define presets.
VERBOSE=
DRY=0
READ_ONLY=0
MAKE_MP=0
ADD_OPT=
#
COPTS=
while :
do
	if
		test -z "$COPTS"
	then
		case "$1" in
			-?*) COPTS="$1"; shift;;
			*) break;;
		esac
	fi
	if
		test "${COPTS#--}" = "$COPTS"
	then
		TAIL="${COPTS#-?}"; # Switch clustering.
		COPT="${COPTS%$TAIL}"; COPTS="${TAIL:+-}$TAIL"
	else
		COPT="$COPTS"; COPTS=
	fi
	# Any arguments are at $1 and onwards; must be shifted off.
	case "$COPT" in
		--) break;; # Must be first!
		--verbose | -v) VERBOSE=Y;;
		--dry-run | --simulate | -n) DRY=1;;
		--read-only | -r) READ_ONLY=1;;
		--options | -o) ADD_OPT="$1"; shift;;
		--create-mountpoint | -c | -m) MAKE_MP=1;;
                --help | -h) show_help | less --quit-if-one-screen; exit;;
		--version) show_version; exit;;
		*) die "Unknown option '$COPT'!";; # Must be last!
	esac
done
# Shift off ordinal arguments. Required arguments first.
test $# -ge 1 || die "Missing argument - <device>!"
DEVICE="$1"; shift
test $# -ge 1 || die "Missing argument - <mount_point_directory>!"
MOUNT_POINT="$1"; shift
# Optional arguments.
#test $# -ge 1 && { WORKDIR="$1"; shift; }
# Check for excess arguments.
test $# = 0 || die "Unexpected excess arguments: $*"
# End of command line processing.
CPFX=
test $DRY = 1 && CPFX=echo
OPT="$MOPT_VFAT_BASE"
if
	test "$READ_ONLY" -ne 0
then
	OPT="$MOPT_VFAT_RO,$OPT"
else
	OPT="$MOPT_VFAT_RW,$OPT"
fi
OPT="$OPT${ADD_OPT:+,}$ADD_OPT"
if
	test -b "$DEVICE"
then
	system readlink -f "$DEVICE"; REAL_PATH=$REPLY
	if
		test x"$REAL_PATH" != x"$DEVICE"
	then
		inform "The resolved device path is '$REAL_PATH'."
	fi
	REAL_PATH=${REAL_PATH##*/}
	while
		REPLY=${REAL_PATH%[0-9]}
		test x"$REAL_PATH" != x"$REPLY"
	do
		REAL_PATH=$REPLY
	done
	REAL_PATH=${IOSCHED_SYSPATH%%'*'*}$REAL_PATH${IOSCHED_SYSPATH##*'*'}
	if
		test -f "$REAL_PATH"
	then
		HAVE_MOD=already
		while
			system cat "$REAL_PATH"
			test x"${REPLY%${PREFER_IOSCHEDULER}*}" = x"$REPLY"
		do
			if test $HAVE_MOD = loaded
			then
				when_real HAVE_MOD=
				break
			fi
			inform "Trying to load i/o scheduler module" \
				"'$IOSCHEDULER_MODULE'."
			when_real silent modprobe "$IOSCHEDULER_MODULE"
			when_real run sleep 1
			HAVE_MOD=loaded
		done
		if
			test -n "$HAVE_MOD" && {
				system cat "$REAL_PATH"
				test x"${REPLY%'['$PREFER_IOSCHEDULER']'*}" \
					= x"$REPLY"
			}
		then
			inform "Changing i/o scheduler for device to" \
				"'$PREFER_IOSCHEDULER'."
			when_real write_to "$PREFER_IOSCHEDULER" "$REAL_PATH"
		fi
	fi
else
	if
		test -f "$DEVICE"
	then
		inform "Device seems to be an image file;" \
			"will try to loop-mount it."
		OPT="$OPT${OPT:+,}loop"
	else
		die "'$DEVICE' is neither an image file" \
			" nor a block special device!"
	fi
fi
if
	test -e "$MOUNT_POINT"
then
	if
		test ! -d "$MOUNT_POINT"
	then
		die "Mount point '$MOUNT_POINT' is not a directory!"
	fi
elif test "$MAKE_MP" -ne 0
then
	if
		! when_real mkdir "$MOUNT_POINT"
	then
		die "Cannot create mount point directory '$MOUNT_POINT'!"
	fi
	if
		! when_real chown nobody:nogroup "$MOUNT_POINT"
	then
		die "Cannot set owner for mount point '$MOUNT_POINT'!"
	fi
	if
		! when_real chmod 0 "$MOUNT_POINT"
	then
		die "Cannot set permissions for mount point '$MOUNT_POINT'!"
	fi
	inform "Created new mount point directory '$MOUNT_POINT'."
else
	die "Mount point '$MOUNT_POINT' does not exist!"
fi
if
	! when_real mount -o"$OPT" "$DEVICE" "$MOUNT_POINT"
then
	die "Could not mount '$DEVICE' as '$MOUNT_POINT'!"
fi
inform "Successfully mounted!"
